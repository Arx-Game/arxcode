# Generated by Django 2.2.16 on 2021-03-31 12:39

from django.db import migrations
from collections import defaultdict

from world.crafting.migration_helpers import (
    get_material_mapping,
    get_val,
    parse_result,
    get_crafting_mapping,
)


def move_material_types_model(apps, schema_editor):
    """This moves material types between apps."""
    OldMat = apps.get_model("dominion", "CraftingMaterialType")
    NewMat = apps.get_model("crafting", "CraftingMaterialType")
    mats = []
    for mat in OldMat.objects.all():
        print(f"Copying material type: {mat.name}")
        contraband = False
        if mat.acquisition_modifiers:
            contraband = "nosell" in mat.acquisition_modifiers
        mats.append(
            NewMat(
                name=mat.name,
                desc=mat.desc,
                category=mat.category,
                value=mat.value,
                contraband=contraband,
            )
        )
    NewMat.objects.bulk_create(mats)


def populate_materials_for_owners_and_adorns(apps, schema_editor):
    """Adds owned materials to AssetOwners and moves Adornments from Attributes"""
    # create mapping of old PK to new PK for material types, since Attributes are by old material PK
    OldOwnedMat = apps.get_model("dominion", "CraftingMaterials")
    OwnedMaterial = apps.get_model("crafting", "OwnedMaterial")
    AdornedMaterial = apps.get_model("crafting", "AdornedMaterial")
    Attribute = apps.get_model("typeclasses", "Attribute")
    mapping = get_material_mapping(apps)
    owned = []
    adorns = []
    for old in OldOwnedMat.objects.all():
        new_type = mapping[old.type_id]
        owned.append(
            OwnedMaterial(type=new_type, amount=old.amount, owner_id=old.owner_id)
        )
    if owned:
        print(f"Populating owners of materials (length: {len(owned)})")
        OwnedMaterial.objects.bulk_create(owned)
    qs = Attribute.objects.filter(db_key="adorns")
    num_failures = 0
    for attr in qs:
        try:
            objdb = attr.objectdb_set.all()[0]
            for key, val in attr.db_value.items():
                new_type = mapping[key]
                adorns.append(
                    AdornedMaterial(type=new_type, amount=val, objectdb=objdb)
                )
        except (IndexError, KeyError, ValueError, TypeError, AttributeError) as err:
            num_failures += 1
            continue
    if num_failures:
        print(f"Number of failures in converting adorns: {num_failures}")
    if adorns:
        print(f"Populating adorns: length {len(adorns)}")
        AdornedMaterial.objects.bulk_create(adorns)
    qs.delete()


def move_recipes(apps, schema_editor):
    """
    Moves the recipe models, setting fields from the old resultsdict, and transferring owners.
    Also populates RequiredMaterial table.
    """
    OldRecipe = apps.get_model("dominion", "CraftingRecipe")
    NewRecipe = apps.get_model("crafting", "CraftingRecipe")
    RequiredMaterial = apps.get_model("crafting", "RequiredMaterial")
    mats_mapping = get_material_mapping(apps)
    reqs = []
    for old in OldRecipe.objects.all():
        print(f"Copying Recipe: {old.name}")
        # get fields from results dict
        rdict = parse_result(old.result)
        slot = rdict.get("slot", "")
        slot_limit = get_val(rdict, "slot_limit", 1, int)
        base_value = get_val(rdict, "baseval", 0.0, float)
        scaling = get_val(rdict, "scaling", 0.0, float)
        armor_penalty = get_val(rdict, "penalty", 0.0, float)
        # fashion_mult is nullable
        fashion_mult = get_val(rdict, "fashion_mult", None, float)
        weapon_skill = rdict.get("weapon_skill", "")
        displayable = rdict.get("displayable", "").lower() == "true"
        display_by_line = rdict.get("display_by_line", "").lower() == "true"
        volume = get_val(rdict, "volume", 1, int)
        new = NewRecipe.objects.create(
            name=old.name or "",
            desc=old.desc or "",
            difficulty=old.difficulty or 0,
            additional_cost=old.additional_cost or 0,
            ability=old.ability or "",
            skill=old.skill or "",
            type=old.type or "",
            level=old.level or 0,
            allow_adorn=old.allow_adorn or False,
            lock_storage=old.lock_storage or "",
            slot=slot,
            slot_limit=slot_limit,
            base_value=base_value,
            scaling=scaling,
            armor_penalty=armor_penalty,
            fashion_mult=fashion_mult,
            weapon_skill=weapon_skill,
            displayable=displayable,
            display_by_line=display_by_line,
            volume=volume,
        )
        # add owners
        new.known_by.set(old.known_by.all())
        # add required materials
        for mat in old.primary_materials.all():
            new_mat = mats_mapping[mat.id]
            reqs.append(
                RequiredMaterial(recipe=new, type=new_mat, amount=old.primary_amount)
            )
        for mat in old.secondary_materials.all():
            new_mat = mats_mapping[mat.id]
            reqs.append(
                RequiredMaterial(recipe=new, type=new_mat, amount=old.secondary_amount)
            )
        for mat in old.tertiary_materials.all():
            new_mat = mats_mapping[mat.id]
            reqs.append(
                RequiredMaterial(recipe=new, type=new_mat, amount=old.tertiary_amount)
            )
    RequiredMaterial.objects.bulk_create(reqs)


def populate_crafting_records(apps, schema_editor):
    """
    TPopulates all crafting records from a variety of Attributes set on objects.
    We'll get a mapping of old to new recipes, and build a defaultdict of the
    CraftingRecord that will hold the values that are present in different Attributes.
    We'll iterate through all the Attributes, and try to update the CraftingRecord that
    corresponds to the ObjectDB instance they're attached to.
    """
    # create mapping of old PK to new PK for recipes, since Attributes are by old recipe PK
    recipe_mapping = get_crafting_mapping(apps)
    Attribute = apps.get_model("typeclasses", "Attribute")
    CraftingRecord = apps.get_model("crafting", "CraftingRecord")
    ObjectDB = apps.get_model("objects", "ObjectDB")
    # we'll have a dict of ObjectDB ids to a crafting record
    record_dict = defaultdict(CraftingRecord)
    recipe_attrs = Attribute.objects.filter(db_key="recipe")
    num_failures = 0
    for attr in recipe_attrs:
        try:
            objdb = attr.objectdb_set.all()[0]
            new_recipe = recipe_mapping[int(attr.db_value)]
            record_dict[objdb.id].recipe = new_recipe
            record_dict[objdb.id].objectdb = objdb
        except (IndexError, KeyError, ValueError, TypeError, AttributeError) as err:
            num_failures += 1
            continue
    quality_attrs = Attribute.objects.filter(db_key="quality_level")
    for attr in quality_attrs:
        try:
            objdb = attr.objectdb_set.all()[0]
            quality = int(attr.db_value)
            if quality < 0:
                quality = 0
            record_dict[objdb.id].quality_level = quality
            record_dict[objdb.id].objectdb = objdb
        except (IndexError, KeyError, ValueError, TypeError, AttributeError) as err:
            num_failures += 1
            continue
    char_ids = set(
        ObjectDB.objects.filter(
            db_typeclass_path="typeclasses.characters.Character"
        ).values_list("id", flat=True)
    )
    crafter_attrs = Attribute.objects.filter(db_key="crafted_by")
    for attr in crafter_attrs:
        try:
            objdb = attr.objectdb_set.all()[0]
            crafter_id = attr.db_value[3]
            if crafter_id not in char_ids:
                continue
            record_dict[objdb.id].crafted_by_id = crafter_id
            record_dict[objdb.id].objectdb = objdb
        except (IndexError, KeyError, ValueError, TypeError, AttributeError) as err:
            num_failures += 1
            continue
    if num_failures:
        print(f"Number of failures in converting crafting records: {num_failures}")
    if record_dict:
        print(f"Populating CraftingRecords: length {len(record_dict.values())}")
        CraftingRecord.objects.bulk_create(record_dict.values())
    recipe_attrs.delete()
    quality_attrs.delete()
    crafter_attrs.delete()


def convert_translations(apps, schema_editor):
    """Convert translated text from Attributes"""
    TranslatedDescription = apps.get_model("crafting", "TranslatedDescription")
    Attribute = apps.get_model("typeclasses", "Attribute")
    qs = Attribute.objects.filter(db_key="translation")
    lang_translations = []
    num_failures = 0
    for attr in qs:
        try:
            objdb = attr.objectdb_set.all()[0]
            for language, desc in attr.db_value.items():
                lang_translations.append(
                    TranslatedDescription(
                        objectdb=objdb, language=language, description=desc
                    )
                )
        except (IndexError, KeyError, ValueError, TypeError, AttributeError) as err:
            num_failures += 1
            continue
    if num_failures:
        print(f"Number of failures in converting translations: {num_failures}")
    if lang_translations:
        print(f"Converting translations: length {len(lang_translations)}")
        TranslatedDescription.objects.bulk_create(lang_translations)
    qs.delete()


def convert_refining(apps, schema_editor):
    """Convert refining records from Attributes"""
    RefineAttempt = apps.get_model("crafting", "RefineAttempt")
    CraftingRecord = apps.get_model("crafting", "CraftingRecord")
    Attribute = apps.get_model("typeclasses", "Attribute")
    records = {ob.objectdb_id: ob for ob in CraftingRecord.objects.all()}
    qs = Attribute.objects.filter(db_key="refine_attempts")
    refine_attempts = []
    num_failures = 0
    for attr in qs:
        try:
            objdb = attr.objectdb_set.all()[0]
            for craft_obj_id, attempts in attr.db_value.items():
                refine_attempts.append(
                    RefineAttempt(
                        record=records[craft_obj_id],
                        num_attempts=attempts,
                        crafter=objdb,
                    )
                )
        except (IndexError, KeyError, ValueError, TypeError, AttributeError) as err:
            num_failures += 1
            continue
    if num_failures:
        print(f"Number of failures in converting refine attempts: {num_failures}")
    if refine_attempts:
        print(f"Converting refine attempts: length {len(refine_attempts)}")
        RefineAttempt.objects.bulk_create(refine_attempts)
    qs.delete()


def convert_mask_descs(apps, schema_editor):
    MaskedDescription = apps.get_model("crafting", "MaskedDescription")
    Attribute = apps.get_model("typeclasses", "Attribute")
    qs = Attribute.objects.filter(db_key="maskdesc")
    maskdescs = []
    num_failures = 0
    for attr in qs:
        try:
            objdb = attr.objectdb_set.all()[0]
            maskdescs.append(
                MaskedDescription(objectdb=objdb, description=attr.db_value)
            )
        except (IndexError, KeyError, ValueError, TypeError, AttributeError) as err:
            num_failures += 1
            continue
    if num_failures:
        print(f"Number of failures in converting mask descs: {num_failures}")
    if maskdescs:
        print(f"Converting maskdescs: length {len(maskdescs)}")
        MaskedDescription.objects.bulk_create(maskdescs)
    qs.delete()


class Migration(migrations.Migration):

    dependencies = [
        ("crafting", "0001_initial"),
    ]

    operations = [
        migrations.RunPython(
            move_material_types_model, migrations.RunPython.noop, elidable=True
        ),
        migrations.RunPython(
            populate_materials_for_owners_and_adorns,
            migrations.RunPython.noop,
            elidable=True,
        ),
        migrations.RunPython(move_recipes, migrations.RunPython.noop, elidable=True),
        migrations.RunPython(
            populate_crafting_records, migrations.RunPython.noop, elidable=True
        ),
        migrations.RunPython(
            convert_translations, migrations.RunPython.noop, elidable=True
        ),
        migrations.RunPython(
            convert_refining, migrations.RunPython.noop, elidable=True
        ),
        migrations.RunPython(
            convert_mask_descs, migrations.RunPython.noop, elidable=True
        ),
    ]
