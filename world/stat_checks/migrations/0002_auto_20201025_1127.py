# Generated by Django 2.2.16 on 2020-10-25 11:27

from django.db import migrations, models
import django.db.models.deletion


def add_armor_class_and_boss_rating_traits(apps, schema_editor):
    """
    Adds traits for armor_class and boss_rating. Note that this is not elidable,
    because it will populate test database
    """
    Trait = apps.get_model("traits", "Trait")
    StatWeight = apps.get_model("stat_checks", "StatWeight")
    OTHER = 3
    MISC = 7
    Trait.objects.get_or_create(
        name="armor_class", defaults=dict(category="combat", trait_type=OTHER)
    )
    Trait.objects.get_or_create(
        name="boss_rating", defaults=dict(category="combat", trait_type=OTHER)
    )
    Trait.objects.get_or_create(
        name="bonus_max_hp", defaults=dict(category="combat", trait_type=OTHER)
    )
    StatWeight.objects.get_or_create(stat_type=MISC)


def change_armor_class_and_boss_rating_attributes_to_traits(apps, schema_editor):
    """Convert existing Attributes for boss_rating and armor_class to their new traits"""
    attr_names = ("armor_class", "boss_rating")
    Attribute = apps.get_model("typeclasses", "Attribute")
    Trait = apps.get_model("traits", "Trait")
    CharacterTraitValue = apps.get_model("traits", "CharacterTraitValue")
    qs = Attribute.objects.filter(db_key__in=attr_names)
    traits = {ob.name.lower(): ob for ob in Trait.objects.filter(name__in=attr_names)}
    bulk_list = {}
    for ob in qs:
        try:
            objdb = ob.objectdb_set.all()[0]
            trait = traits[ob.db_key]
            value = int(ob.db_value)
            if value:
                bulk_list[(objdb, trait)] = CharacterTraitValue(
                    character=objdb, trait=trait, value=int(ob.db_value)
                )
            print(f"Converted {ob.id} ({ob.db_key})")
            ob.delete()
        except (AttributeError, ValueError, TypeError, IndexError, KeyError) as err:
            print(f"Failed to convert {ob.id} ({ob.db_key}): {err}")
            ob.delete()
            continue

    # create all the values as a bulk operation
    CharacterTraitValue.objects.bulk_create(bulk_list.values())


def add_initial_checks(apps, schema_editor):
    """
    Adds a few starting checks for later
    """
    USE_HIGHEST = 1
    CheckCondition = apps.get_model("stat_checks", "CheckCondition")
    TraitsInCombination = apps.get_model("stat_checks", "TraitsInCombination")
    StatCombination = apps.get_model("stat_checks", "StatCombination")
    StatCheck = apps.get_model("stat_checks", "StatCheck")
    Trait = apps.get_model("traits", "Trait")
    StatCheckOutcome = apps.get_model("stat_checks", "StatCheckOutcome")
    RollResult = apps.get_model("stat_checks", "RollResult")
    CheckDifficultyRule = apps.get_model("stat_checks", "CheckDifficultyRule")
    DifficultyRating = apps.get_model("stat_checks", "DifficultyRating")
    # all things required for death save, the check to prevent death
    # define dice systems for death save
    death_save_system = StatCombination.objects.create()
    death_save = StatCheck.objects.create(
        name="death save",
        dice_system=death_save_system,
        description="A check to stay alive. Success indicates the character lives.",
    )
    # set traits used for death save
    armor_class = Trait.objects.get(name="armor_class")
    stamina = Trait.objects.get(name="stamina")
    willpower = Trait.objects.get(name="willpower")
    luck = Trait.objects.get(name="luck")
    higher_of_willpower_or_luck = StatCombination.objects.create(
        combination_type=USE_HIGHEST, combined_into=death_save_system
    )
    TraitsInCombination.objects.create(
        trait=willpower, stat_combination=higher_of_willpower_or_luck
    )
    TraitsInCombination.objects.create(
        trait=luck, stat_combination=higher_of_willpower_or_luck
    )
    TraitsInCombination.objects.create(
        trait=stamina, stat_combination=death_save_system
    )
    TraitsInCombination.objects.create(
        trait=armor_class, stat_combination=death_save_system
    )
    # we map different difficulties to check conditions that are the percent of missing health
    # easy is when they have 100% of their health missing - they just hit 0
    easy_condition = CheckCondition.objects.create(value=100)
    easy = DifficultyRating.objects.get(name="easy")
    normal_condition = CheckCondition.objects.create(value=125)
    normal = DifficultyRating.objects.get(name="normal")
    hard_condition = CheckCondition.objects.create(value=150)
    hard = DifficultyRating.objects.get(name="hard")
    daunting_condition = CheckCondition.objects.create(value=195)
    daunting = DifficultyRating.objects.get(name="daunting")
    CheckDifficultyRule.objects.create(
        stat_check=death_save,
        situation=easy_condition,
        difficulty=easy,
        description="The character is expected to survive, but can still die.",
    )
    CheckDifficultyRule.objects.create(
        stat_check=death_save,
        situation=normal_condition,
        difficulty=normal,
        description="Seriously wounded - the character has a good chance of death.",
    )
    CheckDifficultyRule.objects.create(
        stat_check=death_save,
        situation=hard_condition,
        difficulty=hard,
        description="Very serious wounds - more fragile characters are likely to die.",
    )
    CheckDifficultyRule.objects.create(
        stat_check=death_save,
        situation=daunting_condition,
        difficulty=daunting,
        description="Extremely dire wounds - the character is very likely to die.",
    )
    fail = RollResult.objects.get(name="marginally fails")
    success = RollResult.objects.get(name="marginally successful")
    StatCheckOutcome.objects.create(
        stat_check=death_save,
        result=fail,
        description="The character dies on any failure result.",
        effect=1,
    )
    StatCheckOutcome.objects.create(
        stat_check=death_save,
        result=success,
        description="The character lives on any success result.",
    )
    # unconsciousness save
    uncon_save_system = StatCombination.objects.create()
    uncon_save = StatCheck.objects.create(
        name="unconsciousness save",
        dice_system=uncon_save_system,
        description="A check to stay conscious. Failure is being knocked out.",
    )
    TraitsInCombination.objects.create(
        trait=stamina, stat_combination=uncon_save_system
    )
    HEALTH_BELOW_100 = 2
    easy_condition = CheckCondition.objects.create(
        value=1, condition_type=HEALTH_BELOW_100
    )
    normal_condition = CheckCondition.objects.create(
        value=26, condition_type=HEALTH_BELOW_100
    )
    hard_condition = CheckCondition.objects.create(
        value=51, condition_type=HEALTH_BELOW_100
    )
    daunting_condition = CheckCondition.objects.create(
        value=76, condition_type=HEALTH_BELOW_100
    )
    CheckDifficultyRule.objects.create(
        stat_check=uncon_save,
        situation=easy_condition,
        difficulty=easy,
        description="The character is expected to stay conscious, "
        "but can still be knocked out.",
    )
    CheckDifficultyRule.objects.create(
        stat_check=uncon_save,
        situation=normal_condition,
        difficulty=normal,
        description="The character has a good chance of being knocked out.",
    )
    CheckDifficultyRule.objects.create(
        stat_check=uncon_save,
        situation=hard_condition,
        difficulty=hard,
        description="The character is likely to be knocked out.",
    )
    CheckDifficultyRule.objects.create(
        stat_check=uncon_save,
        situation=daunting_condition,
        difficulty=daunting,
        description="The character is very likely to lose consciousness.",
    )
    StatCheckOutcome.objects.create(
        stat_check=uncon_save,
        result=fail,
        description="The character falls unconscious on any failure result.",
        effect=2,
    )
    StatCheckOutcome.objects.create(
        stat_check=uncon_save,
        result=success,
        description="The character remains conscious on any success result.",
    )

    # permanent wound save
    perm_wound_system = StatCombination.objects.create()
    perm_wound_save = StatCheck.objects.create(
        name="permanent wound save",
        dice_system=perm_wound_system,
        description="A check to avoid suffering permanent effects from wounds.",
    )
    TraitsInCombination.objects.create(
        trait=stamina, stat_combination=perm_wound_system
    )
    PERCENT_HEALTH_INFLICTED = 1
    normal_condition = CheckCondition.objects.create(
        value=30, condition_type=PERCENT_HEALTH_INFLICTED
    )
    hard_condition = CheckCondition.objects.create(
        value=45, condition_type=PERCENT_HEALTH_INFLICTED
    )
    daunting_condition = CheckCondition.objects.create(
        value=60, condition_type=PERCENT_HEALTH_INFLICTED
    )
    CheckDifficultyRule.objects.create(
        stat_check=perm_wound_save,
        situation=normal_condition,
        difficulty=normal,
        description="The character has a good chance of taking a lingering wound.",
    )
    CheckDifficultyRule.objects.create(
        stat_check=perm_wound_save,
        situation=hard_condition,
        difficulty=hard,
        description="The character is likely to have a lingering wound.",
    )
    CheckDifficultyRule.objects.create(
        stat_check=perm_wound_save,
        situation=daunting_condition,
        difficulty=daunting,
        description="The character is very likely to have a permanent, lasting wound.",
    )
    botch = RollResult.objects.get(name="catastrophically fails")
    normal_fail = RollResult.objects.get(name="fails")
    StatCheckOutcome.objects.create(
        stat_check=perm_wound_save,
        result=botch,
        description="The character takes a permanent wound on botches/catastrophic failures.",
        effect=4,
    )
    StatCheckOutcome.objects.create(
        stat_check=perm_wound_save,
        result=normal_fail,
        description="The character takes a serious wound on failure/marginal failure.",
        effect=3,
    )
    StatCheckOutcome.objects.create(
        stat_check=perm_wound_save,
        result=success,
        description="The character does not suffer a permanent wound on success.",
    )


class Migration(migrations.Migration):

    dependencies = [
        ("stat_checks", "0001_initial"),
        ("traits", "0002_auto_20201108_1757"),
    ]

    operations = [
        migrations.AlterField(
            model_name="damagerating",
            name="armor_cap",
            field=models.SmallIntegerField(
                default=100,
                help_text="Percentage of armor that is used to reduce damage from max damage to minimum damage. "
                "100 means they get full value of mitigation, 0 nothing.",
                verbose_name="mitigation percentage",
            ),
        ),
        migrations.RenameField(
            model_name="damagerating", old_name="armor_cap", new_name="armor_percentage"
        ),
        migrations.CreateModel(
            name="CheckCondition",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "condition_type",
                    models.PositiveSmallIntegerField(
                        choices=[
                            (0, "Percentage of health missing"),
                            (1, "Percent health inflicted by attack"),
                            (2, "Flat value of health below 100"),
                        ],
                        default=0,
                    ),
                ),
                ("value", models.SmallIntegerField(default=0)),
            ],
            options={
                "unique_together": {("condition_type", "value")},
            },
        ),
        migrations.CreateModel(
            name="StatCombination",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "combination_type",
                    models.PositiveSmallIntegerField(
                        choices=[
                            (0, "Add Values Together"),
                            (1, "Use the Highest Value"),
                            (2, "Use the Lowest Value"),
                        ],
                        default=0,
                    ),
                ),
                (
                    "combined_into",
                    models.ForeignKey(
                        null=True,
                        on_delete=django.db.models.deletion.PROTECT,
                        related_name="child_combinations",
                        to="stat_checks.StatCombination",
                    ),
                ),
            ],
            options={
                "abstract": False,
            },
        ),
        migrations.CreateModel(
            name="TraitsInCombination",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "value_multiplier",
                    models.PositiveSmallIntegerField(
                        default=1, help_text="This is to make a value count more."
                    ),
                ),
                (
                    "value_divisor",
                    models.PositiveSmallIntegerField(
                        default=1,
                        help_text="This can be used to average values in a combination.",
                    ),
                ),
                (
                    "stat_combination",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="trait_combination_values",
                        to="stat_checks.StatCombination",
                    ),
                ),
                (
                    "trait",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="trait_combination_values",
                        to="traits.Trait",
                    ),
                ),
            ],
            options={
                "unique_together": {("stat_combination", "trait")},
            },
        ),
        migrations.AddField(
            model_name="statcombination",
            name="traits",
            field=models.ManyToManyField(
                related_name="stat_combinations",
                through="stat_checks.TraitsInCombination",
                to="traits.Trait",
            ),
        ),
        migrations.CreateModel(
            name="StatCheck",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("name", models.CharField(max_length=150, unique=True)),
                ("description", models.TextField(blank=True)),
                (
                    "dice_system",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.PROTECT,
                        related_name="stat_checks",
                        to="stat_checks.StatCombination",
                    ),
                ),
            ],
            options={
                "abstract": False,
            },
        ),
        migrations.CreateModel(
            name="CheckDifficultyRule",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "description",
                    models.TextField(
                        blank=True,
                        help_text="Description for GMs of when this difficulty rating applies.",
                    ),
                ),
                (
                    "difficulty",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="difficulty_rules",
                        to="stat_checks.DifficultyRating",
                    ),
                ),
                (
                    "situation",
                    models.ForeignKey(
                        blank=True,
                        help_text="Allows you to define a specific circumstance of when this "
                        "difficulty rating should apply, usually in automated checks.",
                        null=True,
                        on_delete=django.db.models.deletion.PROTECT,
                        to="stat_checks.CheckCondition",
                    ),
                ),
                (
                    "stat_check",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="difficulty_rules",
                        to="stat_checks.StatCheck",
                    ),
                ),
            ],
            options={
                "abstract": False,
            },
        ),
        migrations.CreateModel(
            name="StatCheckOutcome",
            fields=[
                (
                    "id",
                    models.AutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "description",
                    models.TextField(
                        help_text="A description for players/GMs of what this given result means in game"
                    ),
                ),
                (
                    "result",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.PROTECT,
                        related_name="outcomes",
                        to="stat_checks.RollResult",
                    ),
                ),
                (
                    "stat_check",
                    models.ForeignKey(
                        on_delete=django.db.models.deletion.CASCADE,
                        related_name="outcomes",
                        to="stat_checks.StatCheck",
                    ),
                ),
                (
                    "effect",
                    models.PositiveSmallIntegerField(
                        default=0,
                        help_text="A coded effect that you want to have trigger.",
                        choices=(
                            (0, "none"),
                            (1, "death"),
                            (2, "unconsciousness"),
                            (3, "serious wound"),
                            (4, "permanent wound"),
                            (5, "healing"),
                            (6, "healing and cure a wound"),
                            (7, "regain below-0% health"),
                            (8, "recover from unconsciousness"),
                        ),
                    ),
                ),
            ],
            options={
                "ordering": ("result__value",),
                "unique_together": {("stat_check", "result")},
            },
        ),
        migrations.AlterField(
            model_name="statweight",
            name="stat_type",
            field=models.PositiveSmallIntegerField(
                choices=[
                    (0, "skill"),
                    (1, "stat"),
                    (2, "ability"),
                    (3, "knack"),
                    (4, "stat with no skill"),
                    (5, "health for stamina"),
                    (6, "health for boss rating"),
                    (7, "miscellaneous values (armor class, etc)"),
                ],
                default=0,
            ),
        ),
        migrations.RunPython(
            add_armor_class_and_boss_rating_traits,
            migrations.RunPython.noop,
            elidable=False,
        ),
        migrations.RunPython(
            change_armor_class_and_boss_rating_attributes_to_traits,
            migrations.RunPython.noop,
            elidable=True,
        ),
        migrations.RunPython(
            add_initial_checks, migrations.RunPython.noop, elidable=False
        ),
    ]
